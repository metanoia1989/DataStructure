# 算法的乐趣
我走入了一个误区，目前思维能力有限，不需要把算法的每个结构都搞的一清二楚，把常用的算法攻克掉，难点等能力更强的时候再来战斗。    

不甚求解反而是我现在所需要的。  

此书所有章节的源代码 www.iTuring.cn/book/1605   
作者的个人博客 http://blog.csdn.net/orbit/  


训练数学建模的能力，对现实问题进行抽象化，然后运用数学知识进行求解。    

# 一些算法题目  
重复数寻找，O(n)时间复杂度  
有一个由若干正整数组成的数列，数列中的每个数都不超过32，已知数列中存在重复的数字，请给出一个算法找出这个数列中所有重复出现的数。
*计数排数*实现重复性数的统计，O(n)的时间复杂度，因为个数不超过32，所以空间开销是能接受的。    

计算太阳的地心视黄经算法，需要计算出平黄经，然后修正地心章动，修正交角章动，修正光行差，最后得到地心视黄经。其中修正地心章动、修正交角章动和修正光行差这三个步骤是对平黄经值的修正。

用三个容积分别为 3升、8升和 5升的水桶如何获得 4升水的问题。
将三个水桶中当前的水量定义为一个状态，将倒水定义为一个驱动状态转换的动作，则这个问题就转换为水桶状态的穷举搜索问题。在解空间中用穷举的方法遍历所有可能的解，并找到最终合法的解是解决最优解问题的常用数学模型。  


0-1背包问题：有 N件物品和一个承重为 C的背包（也可定义为体积），每件物品的重量是 wi ，价值是 pi ，求解将哪几件物品装入背包可使这些物品在重量总和不超过 C的情况下价值总和最大。  
背包问题（knapsack problem）是此类组合优化的 NP 完全问题的统称，比如货箱装载问题、货船载物问题等，因问题最初来源于如何选择最合适的物品装在背包中而得名。这个问题隐含了一个条件，每个物品只有一件，也就是限定每件物品只能选择 0个或 1个，因此又被称为 0-1背包问题。

利用分治法的快速排序
```c
void quick_sort(int *arElem, int p, int r)
{
    if(p < r)
    {
        int mid = partion(arElem, p, r);
        quick_sort(arElem, p, mid - 1);
        quick_sort(arElem, mid + 1, r);
    }
}
```
