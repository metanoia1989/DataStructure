#include <iostream>

//***********************************************************************
// 找到全排列的下一个数
// 在一个整数所包含数字的全部组合中，找到一个大于且大于原数的新整数
// 固定的几个数字，数字的顺序排列最小，逆序排列最大
// 要找到全排列的下一个数，尽量保持高位不变，低位在最小的范围内变换顺序
// 变换顺序的范围大小，则取决于当前整数的逆序区域   
// 如 12354 逆序区域为 54，从倒数第3位开始变，与逆序区域中大于3的最小数进行交换
// 得到数字 12453
// 
// 步骤说明如下：
// 1. 从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的边界。
// 2. 让逆序区域的前一位和逆序区域中大于它的最小的数字交换位置
// 3. 把原来的逆序区域转为顺序状态  
// 
// 字典序算法   
//***********************************************************************
int findTransferPoint(int numbers[], int size);

int* findNearestNumber(int numbers[], int size)
{
    // 从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换的边界  
    int index = findTransferPoint(numbers, size);
    
    // 如果数字置换边界是0，说明整个数组已经逆序，无法得到更大的相同数字组成的整数，返回 null
    if (index == 0) {
        return nullptr;
    }

    // 把逆序区域的前一位和逆序区域中刚刚大于它的数字交换位置
    // 复制并入参，避免直接修改入参 
    
}